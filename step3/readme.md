# buddy算法
在step2的内存池上实现buddy算法。

## chunk
考虑buddy算法的分裂和合并过程，chunk中需要一个标志位表明当前块是否还能继续向前合并（以避免chunk无休止的向前合并）。
此外考虑chunk被使用和空闲时不同，chunk只在空闲时被挂在链表上，因此prev和next指针只在空闲时会被使用，因此调整顺序，userspace将包含prev和next指针。

 地址偏移(Byte) |数据类型| 解释 
 --------|----|------
 0-3 | 整型 |块大小; 用于释放时查询
 4   | uint8 |标志位，是否空闲
 5   | uint8 |标志位，用于表明当前块能否继续向前合并
 6- 7 | 保留
 8-15 | 指针 | next指针(空闲时) or userspace
 16-23 | 指针 |prev指针(空闲时)

## 分裂合并逻辑
* 分裂：所需大小无空闲chunk则向上一slot的链表请求一个chunk，取得chunk后进行分裂(调整块大小、标志位等)，剩余的空间挂到对应list。
* 合并：回收到的chunk，根据块大小检查；尝试向前和向后合并

## 常见的实现中的问题（没有标准答案，都可以）：
* 什么时候停止向前合并，连续页的第一个块，还是初次分裂后的所有块
* 合并是否递归